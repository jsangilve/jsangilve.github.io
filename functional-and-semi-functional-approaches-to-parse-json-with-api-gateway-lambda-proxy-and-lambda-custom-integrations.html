<!DOCTYPE html>
<html lang="en">
  <head>
            <title>HATE THAT CODE</title>
          <meta charset="utf-8" />
          <!-- Mobile Specific Metas
          –––––––––––––––––––––––––––––––––––––––––––––––––– -->
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <!-- Roboto -->
          <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>
          <link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:300' rel='stylesheet' type='text/css'>
          <!--Skeleton CSS
          –––––––––––––––––––––––––––––––––––––––––––––––––– -->
          <link rel="stylesheet" href="/theme/css/pure-min.css">
          <!--Custom CSS-->
          <link rel="stylesheet" href="/theme/css/custom.css">
          <link rel="stylesheet" href="/theme/css/pygment.css">
          <!-- Favicon
          –––––––––––––––––––––––––––––––––––––––––––––––––– -->
          <link rel="icon" type="image/png" href="/theme/images/favicon.png" />




    <meta name="tags" contents="aws" />
    <meta name="tags" contents="lambda" />
    <meta name="tags" contents="typescript" />
    <meta name="tags" contents="api-gateway" />
    <meta name="tags" contents="serverless" />

  </head>
  <body id="index" class="home">
            <div class="container pure-g">
                  <div class="pure-u-1 pure-u-sm-1-12">
                  <header id="banner" class="blog-title">
                    <h1><img src="/theme/images/angry_logo_75.png" /><a href="/">HATE THAT CODE</a></h1>
                      <h2>by josé san gil</h2>
                  </header><!-- /#banner -->
                  <nav id="menu">
                    <ul>
                    </ul>
                  </nav><!-- /#menu -->
<section id="content" class="body article">
  <header>
    <abbr class="published" title="2020-11-23T00:00:00+01:00"> Mon 23 November 2020 </abbr>
    <h2 class="entry-title">
      <a href="/functional-and-semi-functional-approaches-to-parse-json-with-api-gateway-lambda-proxy-and-lambda-custom-integrations.html" rel="bookmark"
         title="Permalink to Functional and semi functional approaches to parse JSON with API Gateway lambda-proxy and lambda (custom) integrations.">Functional and semi functional approaches to parse JSON with API Gateway lambda-proxy and lambda (custom) integrations.</a></h2>
 
  </header>
  <footer class="post-info">
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>This blog post explores functional approaches for parsing — and validating — JSON payloads using JSON Schemas while working with AWS API Gateway and lambda.</p>
<p>There are two alternatives for request/response integration: the lambda proxy integration and the lambda (custom) integration. </p>
<p>You could find some good blog post out there explaining the differences but they can be summarized as:</p>
<ul>
<li>Lambda-proxy-integration: the easiest to setup. Almost no configuration required within the API Gateway, and everything happens within the lambda function code.</li>
<li>Lambda-custom-integration: more flexible and customizable from the API Gateway side. The configuration is required for handling HTTP status codes.</li>
</ul>
<p>Depending on the requirements, and the longevity of the project, you might be working with one or even both of them. I recently found myself in a situation where it was convenient to support both, so I've been exploring how to write consistent code across lambda functions to make this <em>infrastructure difference</em> — the lambda integration —  less prominent within my lambda code.</p>
<p>This post doesn't cover all the difference between both integrations but presents my take on how to consistently parse JSON payloads for both of them. Let's have a quick look at the main difference in terms of the APIEvent:</p>
<p>For the lambda-proxy integration, the request body is provided as a nullable JSON string, while it's a nullable object for the lambda-custom-integration:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// lambda proxy integration</span>
<span class="kr">const</span> <span class="nx">handlerWithLambdaProxyIntegration</span>: <span class="kt">APIGatewayProxyHandler</span> <span class="o">=</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">body</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// lambda custom integration</span>
<span class="kr">const</span> <span class="nx">handlerWithLambdaCustomIntegration</span> <span class="o">=</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span> <span class="c1">// this is an object</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


<p>You might have noticed that <code>handlerWithLambdaCustomIntegration</code> is not properly typed. The types from the <code>aws-lambda</code> aim to cover the lambda-proxy-integration, but not the custom one. Hence, I extended the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/aws-lambda/trigger/api-gateway-proxy.d.ts">api-gateway-proxy.d.ts</a> types.</p>
<div class="highlight"><pre><span></span><code><span class="nx">type</span> <span class="nx">APIEvent</span> <span class="o">=</span> <span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">APIGatewayEvent</span><span class="p">,</span> <span class="s1">&#39;body&#39;</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="p">{</span>
  <span class="nx">body</span>: <span class="kt">object</span> <span class="o">|</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">type</span> <span class="nx">APIGatewayResult</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">APIGatewayProxyResult</span><span class="p">,</span> <span class="s1">&#39;body&#39;</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="p">{</span>
  <span class="nx">body?</span>: <span class="kt">object</span> <span class="o">|</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">type</span> <span class="nx">APIGatewayHandler</span> <span class="o">=</span> <span class="nx">Handler</span><span class="o">&lt;</span><span class="nx">CustomLambda</span><span class="p">,</span> <span class="nx">APIGatewayResult</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>Nothing sophisticated here — this only covers the <code>body</code> attribute — but a base type that can be used for both integrations.</p>
<h3>Parsing and validating using JSON schemas</h3>
<p>For consistently parsing and validating the JSON payloads for different kinds of requests (HTTP POST, PUT, PATCH), I tend to use JSON schemas. For this purpose, the <a href="https://github.com/ajv-validator/ajv">AJV</a> library is a good option. The API is simple to use, it has types, and — according to their benchmarks — it's fast (I haven't corroborated this, but I guess is that, unless your lambda must be extremely fast, it won't introduce a significant overhead).</p>
<p>Let's start setting up AJV and define a basic JSON schema:</p>
<div class="highlight"><pre><span></span><code><span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;test different json parsing options&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// schema containing 3 string fields, but only two of them are required</span>
  <span class="kr">const</span> <span class="nx">jsonSchema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">properties</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">field1</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span> <span class="p">},</span>
      <span class="nx">field2</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span> <span class="p">},</span>
      <span class="nx">field3</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span> <span class="p">},</span>
    <span class="p">},</span>
    <span class="nx">required</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;field1&#39;</span><span class="p">,</span> <span class="s1">&#39;field2&#39;</span><span class="p">],</span>
  <span class="p">};</span>
  <span class="kr">const</span> <span class="nx">ajv</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Ajv</span><span class="p">({</span> <span class="nx">allErrors</span>: <span class="kt">true</span> <span class="p">});</span>
  <span class="kr">const</span> <span class="nx">validate</span> <span class="o">=</span> <span class="nx">ajv</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">jsonSchema</span><span class="p">);</span>

  <span class="nx">test</span><span class="p">(</span><span class="s1">&#39;check different json payloads&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">validate</span><span class="p">({</span><span class="nx">field1</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">field2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">})).</span><span class="nx">toTruthy</span><span class="p">()</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">validate</span><span class="p">({</span><span class="nx">field1</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">field2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">field3</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">})).</span><span class="nx">toBeTruthy</span><span class="p">()</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">validate</span><span class="p">({</span><span class="nx">field1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">field2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">})).</span><span class="nx">toFalsy</span><span class="p">()</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">validate</span><span class="p">({</span><span class="nx">field1</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">field3</span><span class="o">:</span> <span class="s1">&#39;blah&#39;</span><span class="p">})).</span><span class="nx">toFalsy</span><span class="p">()</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div>


<p>The compiled schema is an <code>Ajv.ValidateFunction</code> i.e, a predicate to evaluate the JSON payload. This validated whether a given object matches the specified schema and we have the errors available through the <code>validate.errors</code> array (<code>Ajv.ErrorObject</code> type). However, this will fail if the provided data is null or string.</p>
<p>Let's then try to write a function that given a nullable JSON (object or string), parses, and validates against a JSON schema. We'll try to keep as a premise that the caller of this function should get the parsed and validated JSON when the data is valid, or a list of errors when is not.</p>
<div class="highlight"><pre><span></span><code><span class="kr">class</span> <span class="nx">JSONParserError</span> <span class="kr">extends</span> <span class="nb">Error</span> <span class="p">{</span>
  <span class="kr">constructor</span><span class="p">(</span><span class="kr">public</span> <span class="nx">errors</span><span class="o">:</span> <span class="p">{</span><span class="nx">errorCode</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">message?</span>: <span class="kt">string</span><span class="p">}[])</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">imperativeParseJSON</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">data</span>: <span class="kt">object</span> <span class="o">|</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">validate</span>: <span class="kt">Ajv.ValidateFunction</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">JSONParserError</span><span class="p">({</span><span class="nx">errorCode</span><span class="o">:</span> <span class="s1">&#39;null_json&#39;</span><span class="p">});</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">parsed</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">?</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">:</span> <span class="nx">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">validate</span><span class="p">(</span><span class="nx">parsed</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">parsed</span> <span class="kr">as</span> <span class="nx">T</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">JSONParserError</span><span class="p">([{</span><span class="nx">errorCode</span><span class="o">:</span> <span class="s1">&#39;malformed_json&#39;</span> <span class="p">}]);</span>
  <span class="p">}</span>

  <span class="k">throw</span> <span class="k">new</span> <span class="nx">JSONParserError</span><span class="p">(</span><span class="nx">validate</span><span class="p">.</span><span class="nx">errors</span><span class="o">!</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">keyword</span><span class="p">,</span> <span class="nx">message</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">errorCode</span>: <span class="kt">keyword</span><span class="p">,</span> <span class="nx">message</span> <span class="p">})));</span>
<span class="p">};</span>
</code></pre></div>


<p>In case the code is not self-explanatory, here we defined a function that short-circuits when the payload is null and will try to parse <code>data</code> as a JSON string, before validating against the schema. In case of failure, a <code>JSONParserError</code> exception is thrown.</p>
<p>The <code>JSONParseError</code> is basically wrapping an array of the type <code>{ errorCode: string, message?: string}</code>. I could have extended the JSONParseError and created custom exceptions for <code>null_json</code> and <code>malformed_json</code>, but I preferred to return only one error for the sake of simplicity. Let's see how can we use this function:</p>
<div class="highlight"><pre><span></span><code><span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;test different json parsing options&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ... setup</span>

  <span class="nx">test</span><span class="p">(</span><span class="s1">&#39;parse valid json with imperativeParseJSON&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">validData</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">field1</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
      <span class="nx">field2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">resultObj</span> <span class="o">=</span> <span class="nx">imperativeParseJSON</span><span class="p">(</span><span class="nx">validData</span><span class="p">,</span> <span class="nx">compiledSchema</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">resultObj</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">validData</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">resultString</span> <span class="o">=</span> <span class="nx">imperativeParseJSON</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">validData</span><span class="p">),</span> <span class="nx">compiledSchema</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">resultString</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">validData</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">test</span><span class="p">(</span><span class="s1">&#39;parse invalid json with imperativeParseJSON&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">invalidData</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">field2</span>: <span class="kt">1</span><span class="p">,</span>
      <span class="nx">field3</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="nx">expect</span><span class="p">.</span><span class="nx">assertions</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">imperativeParseJSON</span><span class="p">(</span><span class="nx">invalidData</span><span class="p">,</span> <span class="nx">compiledSchema</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">errors</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">errors</span><span class="p">;</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">();</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">errors</span><span class="p">).</span><span class="nx">toContainObject</span><span class="p">({</span>
        <span class="nx">errorCode</span><span class="o">:</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span>
      <span class="p">});</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">errors</span><span class="p">).</span><span class="nx">toContainObject</span><span class="p">({</span>
        <span class="nx">errorCode</span><span class="o">:</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>


<p>From the lambda handler perspective, a <code>try/catch</code> is required to handle the exception in case of an invalid JSON:</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span> <span class="nx">lambdaHandler</span>: <span class="kt">APIGatewayHandler</span> <span class="o">=</span> <span class="nx">async</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">parsed</span> <span class="o">=</span> <span class="nx">imperativeParseJSON</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span>
    <span class="c1">// ... do something with the parsed payload</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="k">instanceof</span> <span class="nx">JSONParseError</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">statusCode</span>: <span class="kt">400</span><span class="p">,</span>
        <span class="nx">body</span>: <span class="kt">JSON.stringify</span><span class="p">({</span> <span class="nx">errors</span>: <span class="kt">e.errors</span> <span class="p">})</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// catch any other expected exception that could be thrown within the code of the lambda function</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>This is just control-flow based on exceptions. This example is straightforward, but in reality, the more complex a lambda function becomes, the harder is to follow where a specific error came from. Even when this function is certainly not doing <a href="http://langsec.org/papers/langsec-cwes-secdev2016.pdf">shotgun parsing</a> — the payload won't be processed if it doesn't comply with the schema — the respective error response could get intertwined with the lambda's processing code. </p>
<p>Because I particularly dislike this style, I decided to try a functional approach using an Either Type (Result Type).</p>
<p>Once again, there are a few options, but <a href="https://gcanti.github.io/fp-ts/modules/Either.ts.html">fp-ts</a> is probably the most complete functional programming library for Typescript. Let's see how can we redefine the parsing function:</p>
<div class="highlight"><pre><span></span><code><span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">E</span> <span class="nx">from</span> <span class="s1">&#39;fp-ts/lib/Either&#39;</span><span class="p">;</span>

<span class="c1">// created an interface for the error type</span>
<span class="kr">interface</span> <span class="nx">JSONError</span> <span class="p">{</span>
  <span class="nx">errorCode</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">message?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">semiFunctionalParseJSON</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="nx">data</span>: <span class="kt">object</span> <span class="o">|</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">validate</span>: <span class="kt">Ajv.ValidateFunction</span><span class="p">,</span>
<span class="p">)</span><span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">Either</span><span class="o">&lt;</span><span class="nx">JSONError</span><span class="p">[],</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">E</span><span class="p">.</span><span class="nx">left</span><span class="p">([</span><span class="nx">NULL_JSON</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">parsed</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">?</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">:</span> <span class="nx">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validate</span><span class="p">(</span><span class="nx">parsed</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">E</span><span class="p">.</span><span class="nx">left</span><span class="p">(</span><span class="nx">validate</span><span class="p">.</span><span class="nx">errors</span><span class="o">!</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">keyword</span><span class="p">,</span> <span class="nx">message</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">errorCode</span>: <span class="kt">keyword</span><span class="p">,</span> <span class="nx">message</span> <span class="p">})));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">E</span><span class="p">.</span><span class="nx">right</span><span class="p">(</span><span class="nx">parsed</span> <span class="kr">as</span> <span class="nx">T</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">E</span><span class="p">.</span><span class="nx">left</span><span class="p">([</span><span class="nx">MALFORMED_JSON</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>


<p>This new function doesn't throw exceptions but returns an Either type from <code>fp-ts</code>. In case of error (<em>left</em>), we'll return an array of <code>JSONError</code>, or otherwise the parsed JSON (<em>right</em>). From the caller perspective, this code can be now used as follows:</p>
<div class="highlight"><pre><span></span><code><span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;test different json parsing options&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
 <span class="c1">// ...</span>

<span class="nx">test</span><span class="p">(</span><span class="s1">&#39;parse valid json with semiFunctionalParseJSON&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">validData</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">field1</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
    <span class="nx">field2</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="kr">const</span> <span class="nx">resultObject</span> <span class="o">=</span> <span class="nx">semiFunctionalParseJSON</span><span class="p">(</span><span class="nx">validData</span><span class="p">,</span> <span class="nx">compiledSchema</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">whenRight</span><span class="p">(</span><span class="nx">resultObject</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">validData</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">resultString</span> <span class="o">=</span> <span class="nx">semiFunctionalParseJSON</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">validData</span><span class="p">),</span> <span class="nx">compiledSchema</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">whenRight</span><span class="p">(</span><span class="nx">resultString</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">validData</span><span class="p">);</span>
<span class="p">})</span>



<span class="c1">// lambda function</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">isLeft</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;fp-ts/lib/Either&#39;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">lambdaHandler</span>: <span class="kt">APIGatewayHandler</span> <span class="o">=</span> <span class="nx">async</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">parsed</span> <span class="o">=</span> <span class="nx">semiFunctionalParseJSON</span><span class="o">&lt;</span><span class="nx">MyExpectedType</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isLeft</span><span class="p">(</span><span class="nx">parsed</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">statusCode</span>: <span class="kt">400</span><span class="p">,</span>
    <span class="nx">body</span>: <span class="kt">JSON.stringify</span><span class="p">({</span> <span class="nx">errors</span>: <span class="kt">parsed.left</span> <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

  <span class="c1">// processing payload with parsed.right (MyExpectedType)</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


<p>In my opinion, this is simpler. Somebody reading this code just need to read the first two lines to see what happens when the payload doesn't match. No try/catch, and no control-flow based on exceptions. </p>
<p>This example is contrived though, and a very similar result could be achieved without using <code>fp-ts</code>. Even with the <code>imperativeParseJSON</code> version, we could define our own result type or create a wrapper to catch the exception and return a tuple or a similar type with the errors or the parsed payload.</p>
<p>In my experience, the <code>isLeft</code> and <code>isRight</code> functions can feel odd or confusing for developers without FP experience, so at this point deciding between <code>fp-ts</code> or a custom likewise type boils down to taste and the team's agreement.</p>
<p>Because I feel comfortable with this level of <code>fp-ts</code> in my lambda functions, I decided to improve the <code>semiFunctionalParseJSON</code> a bit more:</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span> <span class="nx">semiFunctionalParseJSONv2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="nx">data</span>: <span class="kt">object</span> <span class="o">|</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">validate</span>: <span class="kt">Ajv.ValidateFunction</span><span class="p">,</span>
<span class="p">)</span><span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">Either</span><span class="o">&lt;</span><span class="nx">JSONError</span><span class="p">[],</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">E</span><span class="p">.</span><span class="nx">left</span><span class="p">([</span><span class="nx">NULL_JSON</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="kr">const</span> <span class="nx">parseResult</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> 
    <span class="o">?</span> <span class="nx">E</span><span class="p">.</span><span class="nx">parseJSON</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">MALFORMED_JSON</span><span class="p">])</span> 
    <span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">right</span><span class="p">(</span><span class="nx">data</span> <span class="kr">as</span> <span class="nx">Json</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">E</span><span class="p">.</span><span class="nx">isLeft</span><span class="p">(</span><span class="nx">parseResult</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">parseResult</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">validate</span><span class="p">(</span><span class="nx">parseResult</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
    <span class="o">?</span> <span class="nx">E</span><span class="p">.</span><span class="nx">right</span><span class="p">((</span><span class="nx">parseResult</span><span class="p">.</span><span class="nx">right</span> <span class="kr">as</span> <span class="nx">unknown</span><span class="p">)</span> <span class="kr">as</span> <span class="nx">T</span><span class="p">)</span>
    <span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">left</span><span class="p">(</span><span class="nx">validate</span><span class="p">.</span><span class="nx">errors</span><span class="o">!</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">keyword</span><span class="p">,</span> <span class="nx">message</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">errorCode</span>: <span class="kt">keyword</span><span class="p">,</span> <span class="nx">message</span> <span class="p">})));</span>
<span class="p">};</span>
</code></pre></div>


<p>We can get rid of the <code>try/catch</code> using the <code>fp-ts</code> helper <code>parseJSON</code> to return an <code>Either</code> type. Under the hood, <code>parseJSON</code> is just catching the exception and returning an error accordingly to the <code>onError</code> function. At this point, every parsing step inside <code>semiFunctionalParseJSON2</code> is using an <code>Either</code> type, which we might push a little bit further to transform this function into a pipeline:</p>
<div class="highlight"><pre><span></span><code><span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">E</span> <span class="nx">from</span> <span class="s1">&#39;fp-ts/lib/Either&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">pipe</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;fp-ts/lib/function&#39;</span><span class="p">;</span>


<span class="kr">const</span> <span class="nx">doParseJSON</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span>: <span class="kt">Json</span><span class="p">)</span><span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">Either</span><span class="o">&lt;</span><span class="nx">JSONError</span><span class="p">[],</span> <span class="nx">Json</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
  <span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">?</span> <span class="nx">E</span><span class="p">.</span><span class="nx">parseJSON</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">MALFORMED_JSON</span><span class="p">])</span> <span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">right</span><span class="p">(</span><span class="nx">data</span> <span class="kr">as</span> <span class="nx">Json</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">validateSchema</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">validate</span>: <span class="kt">Ajv.ValidateFunction</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="nx">json</span>: <span class="kt">Json</span><span class="p">,</span>
<span class="p">)</span><span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">Either</span><span class="o">&lt;</span><span class="nx">JSONError</span><span class="p">[],</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
  <span class="nx">validate</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span>
    <span class="o">?</span> <span class="nx">E</span><span class="p">.</span><span class="nx">right</span><span class="p">((</span><span class="nx">json</span> <span class="kr">as</span> <span class="nx">unknown</span><span class="p">)</span> <span class="kr">as</span> <span class="nx">T</span><span class="p">)</span>
    <span class="o">:</span> <span class="c1">// at this point we know `validate.errors` is not null or undefined</span>
      <span class="nx">E</span><span class="p">.</span><span class="nx">left</span><span class="p">(</span><span class="nx">validate</span><span class="p">.</span><span class="nx">errors</span><span class="o">!</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">fromAjvErrorToJsonError</span><span class="p">));</span>

<span class="kr">const</span> <span class="nx">parseJSON</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="nx">data</span>: <span class="kt">Json</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">schema</span>: <span class="kt">JsonSchemaKey</span> <span class="o">|</span> <span class="nx">JsonSchemaValidator</span><span class="p">,</span>
<span class="p">)</span><span class="o">:</span> <span class="nx">E</span><span class="p">.</span><span class="nx">Either</span><span class="o">&lt;</span><span class="nx">JSONError</span><span class="p">[],</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
  <span class="nx">pipe</span><span class="p">(</span>
    <span class="nx">data</span><span class="p">,</span> 
    <span class="nx">E</span><span class="p">.</span><span class="nx">fromNullable</span><span class="p">([</span><span class="nx">NULL_JSON</span><span class="p">]),</span> 
    <span class="nx">E</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">doParseJSON</span><span class="p">),</span> 
    <span class="nx">E</span><span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">validateSchema</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">schema</span><span class="p">))</span>
  <span class="p">);</span>
</code></pre></div>


<p>At first, this code looks more difficult. We passed from having a single function (<code>semiFunctionalParseJSONv2</code>) to three different functions. However, it's simpler than it looks. We just separated the tasks of our parse function into smaller functions following the <a href="https://en.wikipedia.org/wiki/SOLID">Single-responsability principle</a> (SRP). The defined pipeline will only succeed if:</p>
<ol>
<li>The provided payload is not nullable.</li>
<li>When JSON string, it could be successfully parsed.</li>
<li>The parsed object matches the given JSON schema.</li>
</ol>
<p>Each of these functions returns an <code>Either</code> type that gets chained. At runtime, the pipeline won't apply any further operation as soon as one of the steps returns an error. Similarly, because of type safety, each step should comply with the following contract: return a <code>JSONError</code> array or <code>data</code>.</p>
<p>Is this necessary? do you really need to use a pipe operator? Well, all valid questions with the same answer: it depends. The same results could be achieved without any of the functional abstractions, but in my opinion — and I recognize my own bias because of some relative experience with functional languages — they could bring some clarity to the code. While reading the <code>parseJSON</code> code, you can identify the happy path — and the steps involved — while the function signature and each step/function specify the error cases.</p>
<p>If further validation of the JSON is required, new steps could be added to the pipeline seamlessly (as long as the types do not change).</p>
<p>Once again, this example is contrived and other use cases implemented with fp-ts might not result in simpler or more readable code. Similarly. the concepts shown here could be also applied to the lambda function itself. This might be material for another post. For the time being, these are the main takeaways from this post:</p>
<h3>Summary</h3>
<ul>
<li>While parsing the request payload, the differences introduced by each lambda integration could be abstracted by a properly typed parsing function (avoiding shotgun parsing).</li>
<li>Validating the payloads (input) with JSON schemas can bring consistency across your lambda code. You can even go further and generate Typescript types from these schemas to make sure, once the input is parsed, your function is working with exactly what's expected (check <em>Parse, don't validate</em> on the <em>Related articles</em> section below).</li>
<li>Finally, avoid control-flow using exceptions (not only in lambda functions but in general). If you (and your team) are keen on the idea, try <code>fp-ts</code> or write a Result type (<code>Either</code>) for those operations that can inherently fail as parsing.</li>
</ul>
<h3>Related articles</h3>
<ul>
<li><a href="https://medium.com/@lakshmanLD/lambda-proxy-vs-lambda-integration-in-aws-api-gateway-3a9397af0e6d">Lambda-Proxy vs Lambda Integration in AWS API Gateway</a></li>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don't validate</a></li>
<li><a href="https://hackernoon.com/you-dont-understand-the-single-responsibility-principle-abfdd005b137">Think you understand the Single Responsibility Principle?</a></li>
<li><a href="https://jrsinclair.com/articles/2019/elegant-error-handling-with-the-js-either-monad/">Elegant error handling with the Javascript Either monad</a></li>
</ul>
  </div><!-- /.entry-content -->
</section>
                  <!-- /#contentinfo -->
                  </div>
            </div>

            <footer id="contentinfo">
              <div class="container">
                <span>José San Gil / <a href="https://twitter.com/jsangilve">@jsangilve</a></a><span class="credit">logo by AVA ROWELL from the Noun Project</span>
              </div>
            </footer>
            <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-11146701-2', 'auto');
              ga('send', 'pageview');
            </script>
  </body>
</html>