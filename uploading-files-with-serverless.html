<!DOCTYPE html>
<html lang="en">
  <head>
            <title>HATE THAT CODE</title>
          <meta charset="utf-8" />
          <!-- Mobile Specific Metas
          ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <!-- Roboto -->
          <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>
          <link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:300' rel='stylesheet' type='text/css'>
          <!--Skeleton CSS
          ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
          <link rel="stylesheet" href="/theme/css/pure-min.css">
          <!--Custom CSS-->
          <link rel="stylesheet" href="/theme/css/custom.css">
          <link rel="stylesheet" href="/theme/css/pygment.css">
          <!-- Favicon
          ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
          <link rel="icon" type="image/png" href="/theme/images/favicon.png" />




    <meta name="tags" contents="aws" />
    <meta name="tags" contents="lambda" />
    <meta name="tags" contents="typescript" />
    <meta name="tags" contents="s3" />

  </head>
  <body id="index" class="home">
            <div class="container pure-g">
                  <div class="pure-u-1 pure-u-sm-1-12">
                  <header id="banner" class="blog-title">
                    <h1><img src="/theme/images/angry_logo_75.png" /><a href="/">HATE THAT CODE</a></h1>
                      <h2>by jos√© san gil</h2>
                  </header><!-- /#banner -->
                  <nav id="menu">
                    <ul>
                    </ul>
                  </nav><!-- /#menu -->
<section id="content" class="body article">
  <header>
    <abbr class="published" title="2020-07-19T00:00:00+02:00"> Sun 19 July 2020 </abbr>
    <h2 class="entry-title">
      <a href="/uploading-files-with-serverless.html" rel="bookmark"
         title="Permalink to Uploading files with serverless">Uploading files with serverless</a></h2>
 
  </header>
  <footer class="post-info">
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>Uploading a file is one of those common use cases that almost every web application needs. Regardless of whether you're adding a profile picture, uploading a document, or importing a CSV, it is a fairly simple task in almost every language, framework, or library.</p>
<p>I'm working on a side project where uploading and processing files is a fundamental use case. I went for a serverless approach and assumed that uploading a file to S3 from the browser would be a simple task. In fact, it isn't complicated, but I found a couple of hiccups in the process. There are plenty of blog posts out there on how to upload a file to S3 using and AWS lambdas, but there are a few subtleties that you might want to consider first. I tried to compile some of my learnings in the following blog post:</p>
<h3>TLDR üôà</h3>
<ul>
<li>Consider the average size of the file to upload.</li>
<li>If the file size is within the 10MB limit, you can upload the files with one request.</li>
<li>If the file size is over the 10MB limit, you need two requests ( pre-signed url or pre-signed HTTP POST)</li>
</ul>
<h2>‚ë† First option: Amplify JS</h2>
<p>If you're uploading the file from the browser ‚Äî and particularly if your application requires integration with other AWS service ‚Äî Amplify is probably a good option.
Some setup using amplify-cli is required, but it's rather simple ‚Äî unless you decide or need to setup resouces manually.</p>
<p>You will need to install the <a href="https://docs.amplify.aws/cli/start/install#pre-requisites-for-installation">amplify-cli</a>, add the <code>storage</code> library and put the file in S3.</p>
<div class="highlight"><pre><span></span><span class="c1">// App.ts</span>
<span class="kr">import</span> <span class="nx">AWSStorage</span> <span class="nx">from</span> <span class="s1">&#39;@aws-amplify/storage&#39;</span><span class="p">;</span>

<span class="nx">async</span> <span class="kd">function</span> <span class="nx">uploadFile</span><span class="p">(</span><span class="nx">filename</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">file</span>: <span class="kt">string</span> <span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">AWSStorage</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">level</span><span class="o">:</span> <span class="s1">&#39;private&#39;</span><span class="p">,</span>
    <span class="nx">contentType</span><span class="o">:</span> <span class="s1">&#39;audio/m4a&#39;</span><span class="p">,</span>
  <span class="p">});</span>
  <span class="c1">// ... do something with the result</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The documentation for the <code>put</code> method looks as follows:</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Put a file in storage bucket specified to configure method</span>
<span class="cm"> * @param {string} key - key of the object</span>
<span class="cm"> * @param {Object} object - File to be put in bucket</span>
<span class="cm"> * @param {Object} [config] - { level : private|protected|public, contentType: MIME Types,</span>
<span class="cm"> *  progressCallback: function }</span>
<span class="cm"> * @return - promise resolves to object on success</span>
<span class="cm"> */</span>
<span class="nx">put</span><span class="p">(</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">object</span>: <span class="kt">any</span><span class="p">,</span> <span class="nx">config?</span>: <span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>


<p>At first glance, I encountered the options a bit limited, but after having a look at code, I found the following configuration options:</p>
<ul>
<li><code>contentDispoistion</code></li>
<li><code>cache</code></li>
<li><code>contentType</code></li>
<li><code>contentDisposition</code></li>
<li><code>cacheControl</code></li>
<li><code>expires</code></li>
<li><code>metadata</code></li>
<li><code>tagging</code></li>
<li><code>acl</code></li>
</ul>
<p>In my case, <code>metadata</code> or <code>tagging</code> were the required options. Using them is as simple as:</p>
<div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">uploadFile</span> <span class="o">=</span> <span class="nx">async</span> <span class="p">(</span><span class="nx">filename</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">content</span>: <span class="kt">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AWSStorage</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">level</span><span class="o">:</span> <span class="s1">&#39;public&#39;</span><span class="p">,</span>
    <span class="c1">// metadata seems to accept an object as long as the values are string</span>
    <span class="nx">metadata</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">language</span><span class="o">:</span> <span class="s1">&#39;en-US&#39;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c1">// with `tagging` the parameters must be URL encoded</span>
    <span class="nx">tagging</span>: <span class="kt">new</span> <span class="nx">URLSearchParams</span><span class="p">({</span> <span class="nx">filename</span> <span class="p">}).</span><span class="nx">toString</span><span class="p">(),</span>
  <span class="p">});</span>
<span class="p">};</span>
</pre></div>


<h3>‚ö†Ô∏è Disadvantages</h3>
<ul>
<li>If you do not need any other Amplify's library (API, AI, etc) besides storage, <em>it might not be the right tool for the job</em>. You'll be adding circa +100 KB to your bundle to upload a file (overkill). Also, you're forced to add the <code>Auth</code> library (Amazon Cognito).</li>
<li>The setup is simple and convenient, but restrictive. Amplify uploads your files to either <code>private/COGNITO-USER-ID</code>, <code>protected/COGNITO-USER_ID</code> or <code>public</code> path depending on the specified <code>level</code> (see the snippet above). This bucket structure certainly makes sense and suffices common use cases, but ‚Äî as everything in software ‚Äî might not exactly match your requirements.</li>
<li>If your app doesn't use AWS Cognito for authentication, some manual setup is required (IAM policies).</li>
<li>The extra options (metadata, tagging, etc) aren't currently documented (as of July 2020). I doubt they're considered private API but ü§∑üèΩ‚Äç.</li>
</ul>
<h3>Advantages:</h3>
<ul>
<li>Relatively easy to setup.</li>
<li>The library automatically creates a multi-part upload i.e., apps can upload files up to 5 TB ‚Äî which is probably a bad idea, but still possible.</li>
</ul>
<h2>‚ë° Second option: upload the file using the API Gateway and a lambda function</h2>
<p>In my opinion, this is the simplest and most flexible way to upload and process files ‚Äî or trigger the procesing ‚Äî using AWS... as long as your application doesn't require to upload files over 10 MB. </p>
<p>The web application would <code>POST</code> the file to a given HTTP endpoint as binary data. You can find different examples on how to do it out there, but please find below a simple setup using the <a href="https://www.serverless.com/">Serverless framework</a>:</p>
<div class="highlight"><pre><span></span><span class="c1"># serverless.yaml</span>
<span class="nt">provider</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">aws</span>
  <span class="nt">runtime</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nodejs12.x</span>
  <span class="nt">apiGateway</span><span class="p">:</span>
    <span class="c1"># accepted binary type for file uploads</span>
    <span class="nt">binaryMediaTypes</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="s">&#39;multipart/form-data&#39;</span>

<span class="nt">functions</span><span class="p">:</span>
  <span class="c1"># option 1: sync upload</span>
  <span class="nt">uploadFile</span><span class="p">:</span>
    <span class="nt">handler</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">build.uploadFile</span>
    <span class="nt">events</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="nt">http</span><span class="p">:</span>
          <span class="nt">method</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">post</span>
          <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">upload</span>
          <span class="nt">cors</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">true</span>

<span class="nt">resources</span><span class="p">:</span>
  <span class="nt">Resources</span><span class="p">:</span>
    <span class="nt">MyServerlessExampleBucket</span><span class="p">:</span>
      <span class="nt">Type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">AWS::S3::Bucket</span>
      <span class="nt">Properties</span><span class="p">:</span>
        <span class="nt">BucketName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">serverless-example-bucket</span>

    <span class="c1"># define a policy for an existing role</span>
    <span class="nt">UploadFilePolicy</span><span class="p">:</span>
      <span class="nt">Type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">AWS::IAM::Policy</span>
      <span class="nt">Properties</span><span class="p">:</span>
        <span class="nt">PolicyName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">UploadObjects</span>
        <span class="nt">PolicyDocument</span><span class="p">:</span>
          <span class="nt">Version</span><span class="p">:</span> <span class="s">&#39;2012-10-17&#39;</span>
          <span class="nt">Statement</span><span class="p">:</span>
            <span class="p p-Indicator">-</span> <span class="nt">Sid</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">LambdaPutObjects</span>
              <span class="nt">Effect</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Allow</span>
              <span class="nt">Action</span><span class="p">:</span>
                <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">s3:PutObject</span>
                <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">s3:PutObjectTagging</span>
              <span class="nt">Resource</span><span class="p">:</span> 
                <span class="l l-Scalar l-Scalar-Plain">Fn::Join</span><span class="p p-Indicator">:</span>
                  <span class="p p-Indicator">-</span> <span class="s">&quot;&quot;</span>
                  <span class="p p-Indicator">-</span> <span class="p p-Indicator">-</span> <span class="s">&quot;arn:aws:s3:::&quot;</span>
                    <span class="p p-Indicator">-</span> <span class="nt">Ref</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">MyServerlessExampleBucket</span>
                    <span class="p p-Indicator">-</span> <span class="s">&quot;/*&quot;</span>
        <span class="nt">Roles</span><span class="p">:</span>
          <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">serverless-example-dev-us-east-1-role</span> 
</pre></div>


<p>This serverless configuration creates a lambda function integrated with the API Gateway using the <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html">lambda proxy integration</a>. It adds a policy attaching the S3 permissions required to upload a file. Please note that <code>s3:PutObject</code> and <code>s3:PutObjectTagging</code> are required to upload the file and put tags, respectively.</p>
<p>The defined endpoint (<code>POST /upload</code>) handles the request and transforms the payload (the file) into a string, through the lambda proxy integration (extra configuration is required when using the regular lambda integration), before passing it to the lambda function. </p>
<p>We need to configure the API Gateway to accept binary media types i.e., the binary content types that should be accepted by the API.</p>
<p>The API Gateway ‚Äî through the lambda proxy integration ‚Äî transforms the payload into a <code>base64</code> string when the <code>Content-Type</code> header matches the API's binary media types. Otherwise, the proxy integration pass down the payload as string.</p>
<p>For example, let's use <code>multipart/form-data</code>. The API's binary media types has been configured to accept <code>multipart/form-data</code> (see <code>serverless.yaml</code> above).</p>
<p>The lambda function would look like this:</p>
<div class="highlight"><pre><span></span><span class="c1">// uploadFile.ts</span>
<span class="kr">const</span> <span class="nx">uploadFile</span>: <span class="kt">APIGatewayProxyHandler</span> <span class="o">=</span> <span class="nx">async</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">fields</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">parseFormData</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">tags</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">filename</span>: <span class="kt">file.filename</span> <span class="p">};</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">await</span> <span class="nx">s3Client</span>
      <span class="p">.</span><span class="nx">putObject</span><span class="p">({</span>
        <span class="nx">Bucket</span>: <span class="kt">BUCKET_NAME</span><span class="p">,</span>
        <span class="nx">Key</span>: <span class="kt">fields.filename</span> <span class="o">||</span> <span class="nx">file</span><span class="p">.</span><span class="nx">filename</span><span class="p">,</span>
        <span class="nx">Body</span>: <span class="kt">file.content</span><span class="p">,</span>
        <span class="nx">Tagging</span>: <span class="kt">queryString.encode</span><span class="p">(</span><span class="nx">tags</span><span class="p">),</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="nx">promise</span><span class="p">();</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">statusCode</span>: <span class="kt">200</span><span class="p">,</span>
      <span class="nx">body</span>: <span class="kt">JSON.stringify</span><span class="p">({</span> <span class="nx">description</span><span class="o">:</span> <span class="s1">&#39;file created&#39;</span><span class="p">,</span> <span class="nx">result</span><span class="o">:</span> <span class="s1">&#39;ok&#39;</span> <span class="p">}),</span>
    <span class="p">};</span>

  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">_error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this is not ideal error handling, but good enough for the purpose of this example</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">statusCode</span>: <span class="kt">409</span><span class="p">,</span> 
      <span class="nx">body</span>: <span class="kt">JSON.stringify</span><span class="p">({</span> <span class="nx">description</span><span class="o">:</span> <span class="s1">&#39;something went wrong&#39;</span><span class="p">,</span> <span class="nx">result</span><span class="o">:</span> <span class="s1">&#39;error&#39;</span> <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>This lambda function parses the APIGatewayProxy event (see the <code>parseFormData</code> function in the <a href="https://github.com/jsangilve/serverless-example">repository</a> or alternatively check the npm package <a href="https://github.com/francismeynard/lambda-multipart-parser">lambda-multipart-parser</a>), reads the file, and extract other fields from the form data. Then, uploads the file to S3, includes the tags, and customizes the filename when provided.</p>
<p>You can call the function using the following <code>curl</code> request:</p>
<div class="highlight"><pre><span></span>curl -vs --progress-bar -X POST <span class="se">\</span>
  -H <span class="s2">&quot;Content-Type: multipart/form-data&quot;</span> <span class="se">\</span>
  -F <span class="s1">&#39;file=@FILE_TO_UPLOAD.mp3&#39;</span> <span class="se">\</span>
  -F <span class="s1">&#39;filename=my_custom_filename.m4a&#39;</span> <span class="se">\</span>
  --url https://your-api-id.execute-api.us-east-1.amazonaws.com/dev/upload
</pre></div>


<h3>‚ö†Ô∏è Disadvantages</h3>
<ul>
<li>API Gateway limits the payload size to <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html1">10 MB</a>. If you try to upload a file that exceeds the 10 MB limit, the API Gateway return HTTP 413: <code>HTTP content length exceeded 10485760 bytes</code>. </li>
</ul>
<h3>Advantages</h3>
<ul>
<li>Relatively easy to setup</li>
<li>A synchronous flow for uploading and processing files. When the file size doesn't surpass the API Gateway's limit and the required processing can be done quickly, this model is simple to use and integrate with any web application. </li>
<li>Authorization can be added using the API Gateway's authorizers.</li>
</ul>
<h2>‚ë¢ Third option: upload the file using a pre-signed URL</h2>
<p>This option employs an API Gateway's endpoint integrated with a lambda function. The application client requests a pre-signed URL from the endpoint, passing some parameters as metadata and tags (there are some caveats with this one), and uploads the file sending an <code>HTTP PUT</code> request to the pre-signed URL. </p>
<p>Let's see an example on how to this with the <code>serverless</code> framework:</p>
<div class="highlight"><pre><span></span><span class="c1"># serverless.yaml</span>
<span class="nt">Functions</span><span class="p">:</span>
  <span class="c1"># ... other functions</span>
  <span class="nt">createUploadURL</span><span class="p">:</span>
    <span class="nt">handler</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">build.createUploadURL</span>
    <span class="nt">events</span><span class="p">:</span> 
      <span class="p p-Indicator">-</span> <span class="nt">http</span><span class="p">:</span> 
          <span class="nt">method</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">post</span>
          <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">createUploadURL</span>
          <span class="nt">cors</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">true</span>
</pre></div>


<p>The snippet above creates the endpoint in the API Gateway together with a new lambda function called <code>createUploadURL</code>.  Before deploying these changes, we'll need define the function:</p>
<div class="highlight"><pre><span></span><span class="c1">// createUploadUrl.ts</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">createUploadUrl</span>: <span class="kt">APIGatewayProxyHandler</span> <span class="o">=</span> <span class="nx">async</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// expects body to be a JSON containing the required parameters</span>
  <span class="kr">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">body</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">tags</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getUploadParameters</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">s3Client</span><span class="p">.</span><span class="nx">getSignedUrlPromise</span><span class="p">(</span><span class="s1">&#39;putObject&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">Key</span>: <span class="kt">filename</span><span class="p">,</span>
    <span class="nx">Bucket</span>: <span class="kt">BUCKET_NAME</span><span class="p">,</span>
    <span class="nx">Metadata</span>: <span class="kt">tags</span><span class="p">,</span>
    <span class="nx">Tagging</span>: <span class="kt">tags</span> <span class="o">?</span> <span class="nx">queryString</span><span class="p">.</span><span class="nx">encode</span><span class="p">(</span><span class="nx">body</span><span class="p">.</span><span class="nx">tags</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
    <span class="nx">Expires</span>: <span class="kt">90</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">statusCode</span>: <span class="kt">200</span><span class="p">,</span>
    <span class="nx">body</span>: <span class="kt">JSON.stringify</span><span class="p">({</span>
      <span class="nx">url</span><span class="p">,</span>
    <span class="p">}),</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>


<p>The lambda function fetches the form fields, and uses the <code>filename</code> field to create a pre-signed URL. There is caveat though. The <code>getSignedUrlPromise</code> ignores some parameters as <code>Tagging</code>. This is explicitly stated in the javascript SDK's <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#getSignedUrl-property">documentation</a>. Unfortunately, the typescript definitions for <code>getSignedUrlPromise</code> has the function parameters as <code>any</code> (<code>getSignedUrlPromise(operation: string, params: any): Promise&lt;string&gt;</code>), so you might easily miss this detail. </p>
<ul>
<li><em>Note 1</em>: Even when the documentation lists <code>Expires</code> among the parameters that will be ignored, it works. The generated URL (signature), expires after the given number of seconds (90 seconds in the example above).</li>
<li><em>Note 2</em>: I didn't confirm if this behaviour is consistent across S3 SDKs (python, java, go, etc).</li>
</ul>
<p>Therefore, if your application doesn't require Tagging ‚Äî or any other unsupported parameter like SSECustomerKey, ACL, or ContentLength ‚Äî  using a pre-signed url is a good option. Let's see how it looks:</p>
<div class="highlight"><pre><span></span>curl -vs --progress-bar -X POST <span class="se">\</span>
  -F <span class="s1">&#39;filename=fileWithPresignedURL&#39;</span> <span class="se">\</span>
  --url https://your-api-id.execute-api.us-east-1.amazonaws.com/dev/createUploadUrl
</pre></div>


<p>The request above will return a JSON with the following format:</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;THE_PRESIGNED_URL&quot;</span>
<span class="p">}</span>
</pre></div>


<p>Then, we can use another <code>curl</code> command to upload a file:</p>
<div class="highlight"><pre><span></span>curl -vs --progress-bar -X PUT --upload-file myFile.m4a <span class="nv">$THE_PRESIGNED_URL</span>
</pre></div>


<p>If your application does require <code>Tagging</code>, a pre-signed url might not be the best solution, but there is still a work-around: the client application can provide the tags using the <code>x-amz-tagging</code> HTTP header. Before debating about the developer experience of the resulting API, let's see a request example:</p>
<div class="highlight"><pre><span></span>curl -X PUT -H <span class="s2">&quot;x-amz-tagging: filename=fileUploadedWithPresignedURL&quot;</span> <span class="se">\</span>
--upload-file myFile.m4a <span class="nv">$THE_PRESIGNED_URL</span>
</pre></div>


<p>In my opinion, this approach is not ideal. The client application not only needs to send two requests to upload the file, but it also must provide the url encoded tags ‚Äî and/or other parameters ‚Äî as an HTTP header. Too many implementation leaks.</p>
<p>You might have noticed how the lambda function is also passing the tags to the <code>Metadata</code> attribute. Contrary to the <code>Tagging</code> parameter, this works out of the box ‚Äî the uploaded file gets the metadata attributes. No need for encoding.</p>
<ul>
<li><em>Note</em>: if you wonder whether to use metadata or tags, there is an <a href="https://stackoverflow.com/questions/42126348/difference-between-object-tags-and-object-metadata">interesting answer</a> in SO on the topic.</li>
</ul>
<h3>‚ö†Ô∏è Disadvantages</h3>
<ul>
<li>The application flow might vary, but uploading a file always requires two requests: one to get the pre-signed url, another to upload the file.</li>
<li>Tagging doesn't work out of the box. Even when the pre-signed URL is created passing the tags, the uploaded file doesn't get tagged. This <a href="https://github.com/aws/aws-sdk-js/issues/1313">issue</a> has been reported and, according to the <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#getSignedUrl-property">SDK documentation</a>, it doesn't work because some parameters ‚Äî like <code>Tagging</code> ‚Äî aren't supported and must be provided as headers.</li>
</ul>
<h3>Advantages</h3>
<ul>
<li>The file size can be up to 5 GB.</li>
<li>The URL expiration feature might be helpful on some specific use cases e.g. a user must be able to upload a file without signing in.</li>
<li>When uploading big files, the server load ‚Äî or serveless load üòÖ ‚Äî gets transferred to S3. In a traditional web server approach, your server wouldn't be busy handling the files. Meanwhile, in a serverless approach, your lambda functions wouldn't need to be executed to handle the file upload, which, theoretically, translates into a smaller bill ‚Äî <a href="https://aws.amazon.com/s3/pricing/">S3 doesn't charge for data transfer IN</a>.</li>
<li>It can be <a href="https://github.com/prestonlimlianjie/aws-s3-multipart-presigned-upload">combined</a> with multipart uploads. The maximum file (object) size can be up to 5 TB.</li>
</ul>
<h2>‚ë£ Fourth option: upload the file using pre-signed POST</h2>
<p>This option is very similar to a pre-signed URLs, but allows the client application to upload a file using an HTTP POST request. From the S3 documentation:</p>
<blockquote>
<p>Amazon S3 supports HTTP POST requests so that users can upload content directly to Amazon S3. By using POST, end users can authenticate requests without having to pass data through a secure intermediary node that protects your credentials. Thus, HTTP POST has the potential to reduce latency. </p>
</blockquote>
<p>I decided to try this option because of the issues with <code>Tagging</code> and pre-signed URLs. The pre-signed POST supports the parameters expected by the <code>PutObject</code> operation. Let's see how it works:</p>
<p>First, let's add a new function to the <code>serverless.yaml</code> file:</p>
<div class="highlight"><pre><span></span><span class="c1"># serverless.yaml</span>
<span class="nt">Functions</span><span class="p">:</span>
  <span class="c1"># ... other functions</span>
  <span class="nt">createPostUpload</span><span class="p">:</span>
    <span class="nt">handler</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">build.createPostUpload</span>
    <span class="nt">events</span><span class="p">:</span> 
      <span class="p p-Indicator">-</span> <span class="nt">http</span><span class="p">:</span> 
          <span class="nt">method</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">post</span>
          <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">createPostUpload</span>
          <span class="nt">cors</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">true</span>
</pre></div>


<p>Nothing new here. The function definition is quite similar to the pre-signed URL option. The next step is to create the lambda function: </p>
<div class="highlight"><pre><span></span><span class="c1">// createPostUploadURL.ts</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">createPostUploadUrl</span>: <span class="kt">APIGatewayProxyHandler</span> <span class="o">=</span> <span class="nx">async</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// expects body to be a JSON containing the required parameters</span>
    <span class="kr">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">body</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="p">{</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">tags</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getUploadParameters</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>

    <span class="c1">// missing proper error handling</span>
    <span class="kr">const</span> <span class="nx">postObj</span> <span class="o">=</span> <span class="nx">s3Client</span><span class="p">.</span><span class="nx">createPresignedPost</span><span class="p">({</span>
      <span class="nx">Bucket</span>: <span class="kt">BUCKET_NAME</span><span class="p">,</span>
      <span class="nx">Expires</span>: <span class="kt">90</span><span class="p">,</span> <span class="c1">// expiration in seconds</span>
      <span class="c1">// matches any value for tagging</span>
      <span class="nx">Conditions</span>: <span class="kt">tags</span> <span class="o">&amp;&amp;</span> <span class="p">[[</span><span class="s1">&#39;starts-with&#39;</span><span class="p">,</span> <span class="s1">&#39;$tagging&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]],</span>
      <span class="nx">Fields</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">key</span>: <span class="kt">filename</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">});</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">statusCode</span>: <span class="kt">200</span><span class="p">,</span>
      <span class="nx">body</span>: <span class="kt">JSON.stringify</span><span class="p">({</span>
        <span class="nx">url</span>: <span class="kt">postObj.url</span><span class="p">,</span>
        <span class="nx">fields</span><span class="o">:</span> <span class="p">{</span>
          <span class="p">...</span><span class="nx">postObj</span><span class="p">.</span><span class="nx">fields</span><span class="p">,</span>
          <span class="c1">// augment post object with the tagging values</span>
          <span class="nx">tagging</span>: <span class="kt">tags</span> <span class="o">?</span> <span class="nx">buildXMLTagSet</span><span class="p">(</span><span class="nx">tags</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
        <span class="p">},</span>
      <span class="p">}),</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>


<p>We use the SDK's function <code>createPresignedPost</code>. It requires fields and conditions that could be part of the request. The <code>Conditions</code> key defines an array of policy conditions that should be met to upload the file. You can find a specific section about conditions in the <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html#sigv4-ConditionMatching">AWS S3 documentation</a>.</p>
<p>In the example above, when tags are provided, the resulting policy expects a <code>tagging</code> field with any value (an empty string <code>''</code> means any value). However, the S3's <code>PostObject</code> operation still requires this <code>tagging</code> field to contain the set of tags in the following format:</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;Tagging&gt;</span>
  <span class="nt">&lt;TagSet&gt;</span>
    <span class="nt">&lt;Tag&gt;</span>
      <span class="nt">&lt;Key&gt;</span>Tag Name<span class="nt">&lt;/Key&gt;</span>
      <span class="nt">&lt;Value&gt;</span>Tag Value<span class="nt">&lt;/Value&gt;</span>
    <span class="nt">&lt;/Tag&gt;</span>
    ...
  <span class="nt">&lt;/TagSet&gt;</span>
<span class="nt">&lt;/Tagging&gt;</span>
</pre></div>


<p>I added a simple <code>buildXMLTagSet</code> function for this purpose:</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Given a set of tags, produces the expected XML tagging set format (as string)</span>
<span class="cm"> */</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">buildXMLTagSet</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tagset</span>: <span class="kt">Record</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">tagset</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="sb">`</span><span class="si">${</span><span class="nx">acc</span><span class="si">}</span><span class="sb">&lt;Tag&gt;&lt;Key&gt;</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">&lt;/Key&gt;&lt;Value&gt;</span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">&lt;/Value&gt;&lt;/Tag&gt;`</span><span class="p">,</span>
    <span class="s1">&#39;&#39;</span><span class="p">,</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="sb">`&lt;Tagging&gt;&lt;TagSet&gt;</span><span class="si">${</span><span class="nx">tags</span><span class="si">}</span><span class="sb">&lt;/TagSet&gt;&lt;/Tagging&gt;`</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The tagging set could also be generated on the client-side, but given how particular is the format, I prefer ‚Äî if possible ‚Äî to keep this logic within the lambda function. However, if the file (object) tags are dynamic and, for instance, should be defined by the user as part of the upload form, I would suggest generating the XML on the client-side.</p>
<p>Finally, the response is a JSON payload containing the URL to post the file, and the file tags ‚Äî when provided.</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://s3.amazonaws.com/your-bucket&quot;</span><span class="p">,</span>
  <span class="nt">&quot;fields&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;file_to_be_uploaded.ext&quot;</span><span class="p">,</span>
    <span class="nt">&quot;bucket&quot;</span><span class="p">:</span> <span class="s2">&quot;serverless-example-bucket&quot;</span><span class="p">,</span>
    <span class="nt">&quot;X-Amz-Algorithm&quot;</span><span class="p">:</span> <span class="s2">&quot;AWS4-HMAC-SHA256&quot;</span><span class="p">,</span>
    <span class="nt">&quot;X-Amz-Credential&quot;</span><span class="p">:</span> <span class="s2">&quot;ASIAYJBFLSRZPBUTNKWB/20200718/us-east-1/s3/aws4_request&quot;</span><span class="p">,</span>
    <span class="nt">&quot;X-Amz-Date&quot;</span><span class="p">:</span> <span class="s2">&quot;20200718T151836Z&quot;</span><span class="p">,</span>
    <span class="nt">&quot;X-Amz-Security-Token&quot;</span><span class="p">:</span> <span class="s2">&quot;LONG_SECURITY_TOKEN&quot;</span><span class="p">,</span>
    <span class="nt">&quot;Policy&quot;</span><span class="p">:</span> <span class="s2">&quot;ENCODED_POLICY&quot;</span><span class="p">,</span>
    <span class="nt">&quot;X-Amz-Signature&quot;</span><span class="p">:</span> <span class="s2">&quot;SIGNATURE_STRING&quot;</span><span class="p">,</span>
    <span class="nt">&quot;tagging&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;Tagging&gt;&lt;TagSet&gt;&lt;Tag&gt;&lt;Key&gt;tagX&lt;/Key&gt;&lt;Value&gt;valueTagX&lt;/Value&gt;&lt;/Tag&gt;&lt;/TagSet&gt;&lt;/Tagging&gt;&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>A web application using this lambda function will fetch the policy, and POST the form containing the file and policy fields to the given URL. Find below a test using the lambda function to upload a file.</p>
<div class="highlight"><pre><span></span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;upload file&#39;</span><span class="p">,</span> <span class="nx">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// request the upload URL and POST policy</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">status</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span>
    <span class="s1">&#39;https://your-api-id.execute-api.us-east-1.amazonaws.com/dev/createPostUploadUrl&#39;</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="nx">filename</span><span class="o">:</span> <span class="s1">&#39;my_rock_song.m4a&#39;</span><span class="p">,</span>
      <span class="nx">tags</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">genre</span><span class="o">:</span> <span class="s1">&#39;rock&#39;</span><span class="p">,</span>
        <span class="nx">year</span><span class="o">:</span> <span class="s1">&#39;1994&#39;</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span>
  <span class="p">);</span>

  <span class="nx">expect</span><span class="p">(</span><span class="nx">status</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

  <span class="c1">// the form fields contains the policy fields and the file to upload.</span>
  <span class="kr">const</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">...</span><span class="nx">data</span><span class="p">.</span><span class="nx">fields</span><span class="p">,</span>
    <span class="nx">file</span>: <span class="kt">fs.createReadStream</span><span class="p">(</span><span class="s1">&#39;./file_to_upload.m4a&#39;</span><span class="p">),</span>
  <span class="p">};</span>

  <span class="c1">// use the npm package `form-data` to emulate the FormData Web API</span>
  <span class="kr">const</span> <span class="nx">form</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormData</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">fields</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">form</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">const</span> <span class="p">{</span> <span class="nx">status</span>: <span class="kt">uploadStatusCode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span> <span class="nx">form</span><span class="p">,</span> <span class="p">{</span>
    <span class="c1">// AWS requires the Content-Length header</span>
    <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">form</span><span class="p">.</span><span class="nx">getHeaders</span><span class="p">(),</span>
      <span class="s1">&#39;Content-Length&#39;</span><span class="o">:</span> <span class="nx">await</span> <span class="nx">getContentLength</span><span class="p">(</span><span class="nx">form</span><span class="p">),</span>
    <span class="p">},</span>
  <span class="p">});</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">uploadStatusCode</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">204</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>


<p>When using the lambda's response in a real web application, the POST policy fields (see <code>data.fields</code> above) could be set as hidden fields of the form.</p>
<h3>‚ö†Ô∏è Disadvantages</h3>
<ul>
<li>The client application must send two requests: a request to get the pre-signed data (JSON object), and a request to POST the file to S3.</li>
<li>It might be unfair to call the process complicated, but it's definitely not as simple as some of the previous options.</li>
<li>When it comes to <code>tagging</code> the file, the tags should be provided as an XML. If the file tags aren't defined by the user (dynamic), this logic could live inside the lambda function. Otherwise, the expected tagging set format should be generated in the client side. There already a few abstraction leaks in this option, but, in my opinion, this one is particularly cumbersome.</li>
</ul>
<h3>Advantages</h3>
<ul>
<li>Same advantages that pre-signed URLs.</li>
<li>It's the recommended method to upload a file from a web-form.</li>
<li>It's probably the most flexible approach. Metadata, and tags could be provided, while conditions to restrict the POST request can be defined. As a result, every object written to the S3 bucket should contain exactly what is expected.</li>
</ul>
<h2>Conclusion</h2>
<p>As usual, there isn't a silver bullet. The average file size should be the first element to take into consideration when choosing between the four options. If you expect to upload files over 10MB, option ‚ë° can be discarded. On the other hand, you have option ‚ë†. The Amplify framework simplifies things like uploading a file ‚Äî it eliminates the file size problem using multipart uploads ‚Äî or implementing authentication and authorization with Cognito. Unfortunately, some things aren't so simple or well documented (tagging), and your application could get tightly coupled to AWS ‚Äî which might not necessarily be a bad thing. </p>
<p>Ultimately, you have pre-signed URLs (option ‚ë¢) and pre-signed POST  (option ‚ë£). Both require the client-side application to send two requests: one to get the signed URL, and another to upload the file to AWS S3. From the client-side point of view, it's simpler to deal with pre-signed URLs. The client-application fetches a URL, when required, and uploads the file ‚Äî an HTTP PUT request with JS ‚Äî to S3. Unfortunately, some parameters aren't supported (tagging), so workarounds must be employed. The pre-signed POST option is similar but expects a POST request. The payload retrieved from the first request can contain all the information required to upload the file (including tags), it's more flexible, but also more complex.</p>
<p>Once again, no silver bullet, but a bunch of <em>it depends</em>.</p>
<p>You can find the code for the lambda functions in the following repository: https://github.com/jsangilve/serverless-example.</p>
<h3>References</h3>
<ul>
<li><a href="https://blog.webiny.com/upload-files-to-aws-s3-using-pre-signed-post-data-and-a-lambda-function-7a9fb06d56c1">https://blog.webiny.com/upload-files-to-aws-s3-using-pre-signed-post-data-and-a-lambda-function-7a9fb06d56c1</a></li>
<li><a href="https://blog.bigbinary.com/2018/09/04/uploading-files-directly-to-s3-using-pre-signed-post-request.html">https://blog.bigbinary.com/2018/09/04/uploading-files-directly-to-s3-using-pre-signed-post-request.html</a></li>
<li><a href="https://www.serverless.com/blog/s3-one-time-signed-url">https://www.serverless.com/blog/s3-one-time-signed-url</a></li>
<li><a href="https://medium.marqeta.com/pre-signing-aws-s3-urls-136f203a75cd?gi=cf38bc74bdef">https://medium.marqeta.com/pre-signing-aws-s3-urls-136f203a75cd?gi=cf38bc74bdef</a></li>
<li><a href="https://medium.com/swlh/upload-binary-files-to-s3-using-aws-api-gateway-with-aws-lambda-2b4ba8c70b8e">https://medium.com/swlh/upload-binary-files-to-s3-using-aws-api-gateway-with-aws-lambda-2b4ba8c70b8e</a></li>
<li><a href="https://medium.com/@aidan.hallett/securing-aws-s3-uploads-using-presigned-urls-aa821c13ae8d">https://medium.com/@aidan.hallett/securing-aws-s3-uploads-using-presigned-urls-aa821c13ae8d</a></li>
<li><a href="https://sookocheff.com/post/api/uploading-large-payloads-through-api-gateway/">https://sookocheff.com/post/api/uploading-large-payloads-through-api-gateway/</a></li>
<li><a href="https://css-tricks.com/building-your-first-serverless-service-with-aws-lambda-functions/">https://css-tricks.com/building-your-first-serverless-service-with-aws-lambda-functions/</a></li>
</ul>
  </div><!-- /.entry-content -->
</section>
                  <!-- /#contentinfo -->
                  </div>
            </div>

            <footer id="contentinfo">
              <div class="container">
                <span>Jos√© San Gil / <a href="https://twitter.com/jsangilve">@jsangilve</a></a><span class="credit">logo by AVA ROWELL from the Noun Project</span>
              </div>
            </footer>
            <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-11146701-2', 'auto');
              ga('send', 'pageview');
            </script>
  </body>
</html>